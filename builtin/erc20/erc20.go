// Code generated by web3tool/abigen. DO NOT EDIT.
// Hash: a1a873d70d345feef023ee086fd6135b24d775444b950ee9d5ea411e72b0f373
// Version: 0.1.1
package erc20

import (
	"fmt"
	"math/big"

	"github.com/yellomoon/web3tool"
	"github.com/yellomoon/web3tool/contract"
	"github.com/yellomoon/web3tool/jsonrpc"
)

var (
	_ = big.NewInt
	_ = jsonrpc.NewClient
)

// ERC20 is a solidity contract
type ERC20 struct {
	c *contract.Contract
}

// NewERC20 creates a new instance of the contract at a specific address
func NewERC20(addr web3tool.Address, opts ...contract.ContractOption) *ERC20 {
	return &ERC20{c: contract.NewContract(addr, abiERC20, opts...)}
}

// calls

// Allowance calls the allowance method in the solidity contract
func (e *ERC20) Allowance(owner web3tool.Address, spender web3tool.Address, block ...web3tool.BlockNumber) (retval0 *big.Int, err error) {
	var out map[string]interface{}
	var ok bool

	out, err = e.c.Call("allowance", web3tool.EncodeBlock(block...), owner, spender)
	if err != nil {
		return
	}

	// decode outputs
	retval0, ok = out["0"].(*big.Int)
	if !ok {
		err = fmt.Errorf("failed to encode output at index 0")
		return
	}
	
	return
}

// BalanceOf calls the balanceOf method in the solidity contract
func (e *ERC20) BalanceOf(owner web3tool.Address, block ...web3tool.BlockNumber) (retval0 *big.Int, err error) {
	var out map[string]interface{}
	var ok bool

	out, err = e.c.Call("balanceOf", web3tool.EncodeBlock(block...), owner)
	if err != nil {
		return
	}

	// decode outputs
	retval0, ok = out["balance"].(*big.Int)
	if !ok {
		err = fmt.Errorf("failed to encode output at index 0")
		return
	}
	
	return
}

// Decimals calls the decimals method in the solidity contract
func (e *ERC20) Decimals(block ...web3tool.BlockNumber) (retval0 uint8, err error) {
	var out map[string]interface{}
	var ok bool

	out, err = e.c.Call("decimals", web3tool.EncodeBlock(block...))
	if err != nil {
		return
	}

	// decode outputs
	retval0, ok = out["0"].(uint8)
	if !ok {
		err = fmt.Errorf("failed to encode output at index 0")
		return
	}
	
	return
}

// Name calls the name method in the solidity contract
func (e *ERC20) Name(block ...web3tool.BlockNumber) (retval0 string, err error) {
	var out map[string]interface{}
	var ok bool

	out, err = e.c.Call("name", web3tool.EncodeBlock(block...))
	if err != nil {
		return
	}

	// decode outputs
	retval0, ok = out["0"].(string)
	if !ok {
		err = fmt.Errorf("failed to encode output at index 0")
		return
	}
	
	return
}

// Symbol calls the symbol method in the solidity contract
func (e *ERC20) Symbol(block ...web3tool.BlockNumber) (retval0 string, err error) {
	var out map[string]interface{}
	var ok bool

	out, err = e.c.Call("symbol", web3tool.EncodeBlock(block...))
	if err != nil {
		return
	}

	// decode outputs
	retval0, ok = out["0"].(string)
	if !ok {
		err = fmt.Errorf("failed to encode output at index 0")
		return
	}
	
	return
}

// TotalSupply calls the totalSupply method in the solidity contract
func (e *ERC20) TotalSupply(block ...web3tool.BlockNumber) (retval0 *big.Int, err error) {
	var out map[string]interface{}
	var ok bool

	out, err = e.c.Call("totalSupply", web3tool.EncodeBlock(block...))
	if err != nil {
		return
	}

	// decode outputs
	retval0, ok = out["0"].(*big.Int)
	if !ok {
		err = fmt.Errorf("failed to encode output at index 0")
		return
	}
	
	return
}

// txns

// Approve sends a approve transaction in the solidity contract
func (e *ERC20) Approve(spender web3tool.Address, value *big.Int) (contract.Txn, error) {
	return e.c.Txn("approve", spender, value)
}

// Transfer sends a transfer transaction in the solidity contract
func (e *ERC20) Transfer(to web3tool.Address, value *big.Int) (contract.Txn, error) {
	return e.c.Txn("transfer", to, value)
}

// TransferFrom sends a transferFrom transaction in the solidity contract
func (e *ERC20) TransferFrom(from web3tool.Address, to web3tool.Address, value *big.Int) (contract.Txn, error) {
	return e.c.Txn("transferFrom", from, to, value)
}

// events

func (e *ERC20) ApprovalEventSig() web3tool.Hash {
	return e.c.GetABI().Events["Approval"].ID()
}

func (e *ERC20) TransferEventSig() web3tool.Hash {
	return e.c.GetABI().Events["Transfer"].ID()
}
